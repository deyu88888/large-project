import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MemoryRouter, Routes, Route } from 'react-router-dom';
import { PrivateGuard } from '../PrivateGuard';
import { apiClient } from '../../api';
import { jwtDecode } from 'jwt-decode';
import { ACCESS_TOKEN, REFRESH_TOKEN } from '../../constants';
import { useAuthStore } from '../../stores/auth-store';

// Mock dependencies
vi.mock('../../api', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
  apiPaths: {
    USER: {
      CURRENT: '/api/user/current',
      REFRESH: '/api/token/refresh',
    },
  },
}));

vi.mock('jwt-decode', () => ({
  jwtDecode: vi.fn(),
}));

vi.mock('../../stores/auth-store', () => ({
  useAuthStore: vi.fn(),
}));

// Utility function to setup mock localStorage
const setupLocalStorage = (accessToken?: string, refreshToken?: string) => {
  const localStorageMock = {
    getItem: vi.fn(),
    setItem: vi.fn(),
    removeItem: vi.fn(),
  };
  
  localStorageMock.getItem.mockImplementation((key) => {
    if (key === ACCESS_TOKEN) return accessToken || null;
    if (key === REFRESH_TOKEN) return refreshToken || null;
    return null;
  });
  
  Object.defineProperty(window, 'localStorage', {
    value: localStorageMock,
    writable: true,
  });

  return localStorageMock;
};

describe('PrivateGuard Component', () => {
  const mockSetUser = vi.fn();
  const mockChildren = <div>Protected Content</div>;

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks();
    
    // Setup default mock implementations
    (useAuthStore as unknown as vi.Mock).mockReturnValue({
      user: null,
      setUser: mockSetUser,
    });

    (jwtDecode as vi.Mock).mockReturnValue({
      exp: Math.floor(Date.now() / 1000) + 3600, // Token expires in 1 hour
    });
  });

  const renderPrivateGuard = (
    path = '/protected', 
    requiredRole?: 'admin' | 'student',
    mockApiResponse = { data: { id: '123', firstName: 'Test', role: 'student' } }
  ) => {
    (apiClient.get as vi.Mock).mockResolvedValue(mockApiResponse);

    return render(
      <MemoryRouter initialEntries={[path]}>
        <Routes>
          <Route 
            path="/protected" 
            element={
              <PrivateGuard requiredRole={requiredRole}>
                {mockChildren}
              </PrivateGuard>
            } 
          />
          <Route path="/login" element={<div>Login Page</div>} />
          <Route path="/admin" element={<div>Admin Dashboard</div>} />
          <Route path="/student" element={<div>Student Dashboard</div>} />
        </Routes>
      </MemoryRouter>
    );
  };

  it('shows loading view when authenticating', async () => {
    // Simulate a slow authentication process
    (apiClient.get as vi.Mock).mockImplementation(() => new Promise(() => {}));
    
    setupLocalStorage('valid-token');
    
    renderPrivateGuard();

    // Wait for loading view to appear
    const loadingView = await screen.findByTestId('loading-view');
    expect(loadingView).toBeTruthy();
  });

  it('redirects to login when no token is present', async () => {
    setupLocalStorage(); // No tokens
    
    renderPrivateGuard();

    // Check if redirected to login
    const loginPage = await screen.findByText('Login Page');
    expect(loginPage).toBeTruthy();
  });

  it('renders children when token is valid and user data is fetched', async () => {
    setupLocalStorage('valid-token');
    
    renderPrivateGuard();

    // Wait for protected content to appear
    const protectedContent = await screen.findByText('Protected Content');
    expect(protectedContent).toBeTruthy();
  });

  it('handles token refresh when initial token is invalid', async () => {
    // First, make token validation fail
    (jwtDecode as vi.Mock).mockImplementationOnce(() => {
      throw new Error('Invalid token');
    });

    // Mock successful token refresh
    (apiClient.post as vi.Mock).mockResolvedValue({
      status: 200,
      data: { access: 'new-valid-token' }
    });

    setupLocalStorage('invalid-token', 'refresh-token');
    
    renderPrivateGuard();

    // Check if protected content eventually renders
    const protectedContent = await screen.findByText('Protected Content');
    expect(protectedContent).toBeTruthy();
  });

  it('redirects when required role does not match', async () => {
    setupLocalStorage('valid-token');
    
    (useAuthStore as unknown as vi.Mock).mockReturnValue({
      user: { role: 'student' },
      setUser: mockSetUser,
    });

    renderPrivateGuard('/protected', 'admin');

    // Should redirect to student dashboard
    const studentDashboard = await screen.findByText('Student Dashboard');
    expect(studentDashboard).toBeTruthy();
  });

  it('redirects from public routes when authenticated', async () => {
    setupLocalStorage('valid-token');
    
    (useAuthStore as unknown as vi.Mock).mockReturnValue({
      user: { role: 'admin' },
      setUser: mockSetUser,
    });

    renderPrivateGuard('/', undefined);

    // Should redirect to admin dashboard
    const adminDashboard = await screen.findByText('Admin Dashboard');
    expect(adminDashboard).toBeTruthy();
  });

  it('uses fallback user when user data fetch fails', async () => {
    setupLocalStorage('valid-token');
    
    // Make user data fetch fail
    (apiClient.get as vi.Mock).mockRejectedValue(new Error('Fetch failed'));

    renderPrivateGuard();

    // Wait for protected content to appear
    const protectedContent = await screen.findByText('Protected Content');
    expect(protectedContent).toBeTruthy();

    // Verify fallback user was set
    expect(mockSetUser).toHaveBeenCalledWith(
      expect.objectContaining({
        first_name: 'User',
        role: 'student'
      })
    );
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
});