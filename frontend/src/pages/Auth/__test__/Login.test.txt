import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginPage from '../Login';
import { useAuth } from '../../../context/AuthContext';
import { useNavigate, useLocation } from 'react-router-dom';
import { apiClient } from '../../../api';
import { jwtDecode } from 'jwt-decode';

vi.mock('react-router-dom', () => ({
  useNavigate: vi.fn(),
  useLocation: vi.fn(),
}));

vi.mock('../../context/AuthContext', () => ({
  useAuth: vi.fn(),
}));

vi.mock('../../api', () => ({
  apiClient: {
    post: vi.fn(),
  },
  apiPaths: {
    USER: {
      LOGIN: '/api/user/login',
    },
  },
}));

vi.mock('jwt-decode', () => ({
  jwtDecode: vi.fn(),
}));

describe('LoginPage', () => {
  const mockNavigate = vi.fn();
  const mockLogin = vi.fn();
  
  beforeEach(() => {
    vi.clearAllMocks();
    
    useNavigate.mockReturnValue(mockNavigate);
    useLocation.mockReturnValue({ state: {} });
    useAuth.mockReturnValue({ login: mockLogin });
    jwtDecode.mockReturnValue({ user_id: 1, role: 'student' });
  });

  it('renders the login form correctly', () => {
    render(<LoginPage />);
    
    expect(screen.getByTestId('login-heading')).toBeInTheDocument();
    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByTestId('login-button')).toBeInTheDocument();
    expect(screen.getByText(/need to sign up\?/i)).toBeInTheDocument();
  });

  it('allows entering username and password', async () => {
    const user = userEvent.setup();
    render(<LoginPage />);
    
    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    
    await user.type(usernameInput, 'testuser');
    await user.type(passwordInput, 'password123');
    
    expect(usernameInput).toHaveValue('testuser');
    expect(passwordInput).toHaveValue('password123');
  });

  it('toggles password visibility when clicking the icon', async () => {
    const user = userEvent.setup();
    render(<LoginPage />);
    
    const passwordInput = screen.getByLabelText(/password/i);
    expect(passwordInput).toHaveAttribute('type', 'password');
    
    const visibilityToggle = screen.getByRole('button', { name: /visibility/i });
    await user.click(visibilityToggle);
    
    expect(passwordInput).toHaveAttribute('type', 'text');
    
    await user.click(visibilityToggle);
    expect(passwordInput).toHaveAttribute('type', 'password');
  });

  it('submits the form and handles successful login for student', async () => {
    const user = userEvent.setup();
    
    apiClient.post.mockResolvedValueOnce({
      data: {
        access: 'fake-access-token',
        refresh: 'fake-refresh-token',
      },
    });
    
    render(<LoginPage />);
    
    await user.type(screen.getByLabelText(/username/i), 'testuser');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    
    await user.click(screen.getByTestId('login-button'));
    
    expect(apiClient.post).toHaveBeenCalledWith('/api/user/login', {
      username: 'testuser',
      password: 'password123',
    });
    
    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith('fake-access-token', 'fake-refresh-token');
      expect(mockNavigate).toHaveBeenCalledWith('/student', { replace: true });
    });
  });

  it('submits the form and handles successful login for admin', async () => {
    const user = userEvent.setup();
    
    apiClient.post.mockResolvedValueOnce({
      data: {
        access: 'fake-admin-token',
        refresh: 'fake-refresh-token',
      },
    });
    
    jwtDecode.mockReturnValueOnce({ user_id: 2, role: 'admin' });
    
    render(<LoginPage />);
    
    await user.type(screen.getByLabelText(/username/i), 'adminuser');
    await user.type(screen.getByLabelText(/password/i), 'adminpass');
    
    await user.click(screen.getByTestId('login-button'));
    
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/admin', { replace: true });
    });
  });

  it('navigates to the previous route after successful login if available', async () => {
    const user = userEvent.setup();
    
    useLocation.mockReturnValue({
      state: { from: { pathname: '/previous-page' } }
    });
    
    apiClient.post.mockResolvedValueOnce({
      data: {
        access: 'fake-access-token',
        refresh: 'fake-refresh-token',
      },
    });
    
    render(<LoginPage />);
    
    await user.type(screen.getByLabelText(/username/i), 'testuser');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByTestId('login-button'));
    
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/previous-page', { replace: true });
    });
  });

  it('displays loading indicator during form submission', async () => {
    const user = userEvent.setup();
    
    let resolvePromise;
    const delayedPromise = new Promise(resolve => {
      resolvePromise = resolve;
    });
    
    apiClient.post.mockReturnValue(delayedPromise);
    
    render(<LoginPage />);
    
    await user.type(screen.getByLabelText(/username/i), 'testuser');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByTestId('login-button'));
    
    expect(screen.getByTestId('loading-indicator')).toBeInTheDocument();
    
    resolvePromise({ data: { access: 'token', refresh: 'token' } });
    
    await waitFor(() => {
      expect(screen.queryByTestId('loading-indicator')).not.toBeInTheDocument();
    });
  });

  it('displays error message on login failure', async () => {
    const user = userEvent.setup();
    
    apiClient.post.mockRejectedValueOnce(new Error('Login failed'));
    
    render(<LoginPage />);
    
    await user.type(screen.getByLabelText(/username/i), 'testuser');
    await user.type(screen.getByLabelText(/password/i), 'wrongpassword');
    await user.click(screen.getByTestId('login-button'));
    
    await waitFor(() => {
      expect(screen.getByTestId('error-message')).toBeInTheDocument();
      expect(screen.getByText(/login failed/i)).toBeInTheDocument();
    });
  });

  it('disables the login button during submission', async () => {
    const user = userEvent.setup();
    
    let resolvePromise;
    const delayedPromise = new Promise(resolve => {
      resolvePromise = resolve;
    });
    
    apiClient.post.mockReturnValue(delayedPromise);
    
    render(<LoginPage />);
    
    const loginButton = screen.getByTestId('login-button');
    
    await user.type(screen.getByLabelText(/username/i), 'testuser');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(loginButton);
    
    expect(loginButton).toBeDisabled();
    
    resolvePromise({ data: { access: 'token', refresh: 'token' } });
    
    await waitFor(() => {
      expect(loginButton).not.toBeDisabled();
    });
  });
});