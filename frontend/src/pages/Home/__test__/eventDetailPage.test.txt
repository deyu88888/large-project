// failing

import React from 'react';
import { render, screen, waitFor, fireEvent, act } from '@testing-library/react';
import { vi } from 'vitest';
import { MemoryRouter, Routes, Route } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import EventDetailPage from '../eventDetailPage';
import { apiClient } from '../../../api';
import { CommentSection } from '../../../components/CommentSection';

const theme = createTheme({
  palette: {
    mode: 'light',
  }
});

const darkTheme = createTheme({
  palette: {
    mode: 'dark',
  }
});

// Mock the CommentSection component
vi.mock('../../components/CommentSection', () => ({
  CommentSection: vi.fn(() => <div data-testid="comment-section">Mocked Comment Section</div>)
}));

// Mock the apiClient properly
vi.mock('../../api', () => ({
  apiClient: {
    get: vi.fn()
  }
}));

// Mock WebSocket
class MockWebSocket {
  constructor(url) {
    this.url = url;
    this.onopen = null;
    this.onmessage = null;
    this.onerror = null;
    this.onclose = null;
    
    // Simulate connection
    setTimeout(() => {
      if (this.onopen) this.onopen();
    }, 50);
  }

  close() {
    if (this.onclose) this.onclose();
  }
}

global.WebSocket = MockWebSocket;

const mockNavigate = vi.fn();
const mockUseParams = vi.fn().mockReturnValue({ eventId: '123' });

vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom');
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    useParams: () => mockUseParams(),
  };
});

vi.mock('date-fns', async () => {
  const actual = await vi.importActual('date-fns');
  return {
    ...actual,
    format: vi.fn(() => '2023-04-15'), // Mock date formatting
  };
});

describe('EventDetailPage Component', () => {
  const mockEventId = '123';
  
  const mockEvent = {
    id: 123,
    title: 'Test Event',
    description: 'This is a test event description',
    date: '2023-04-15T00:00:00Z',
    start_time: '14:00',
    location: 'Test Location'
  };

  const mockComments = [
    { id: 1, content: 'Great event!', user: 'user1', created_at: '2023-04-16T10:00:00Z' },
    { id: 2, content: 'Looking forward to it', user: 'user2', created_at: '2023-04-16T11:00:00Z' }
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    
    mockUseParams.mockReturnValue({ eventId: mockEventId });
    
    // Set up default mock responses
    apiClient.get.mockImplementation((url) => {
      if (url === `/api/event/${mockEventId}`) {
        return Promise.resolve({ data: mockEvent });
      }
      if (url === '/api/user/current') {
        return Promise.resolve({ status: 200, data: { username: 'testuser' } });
      }
      if (url === `/api/comments/?event_id=${mockEventId}`) {
        return Promise.resolve({ data: mockComments });
      }
      return Promise.reject(new Error('Unhandled API request'));
    });
  });

  const setup = async (useDarkTheme = false, authenticated = true) => {
    if (!authenticated) {
      apiClient.get.mockImplementation((url) => {
        if (url === `/api/event/${mockEventId}`) {
          return Promise.resolve({ data: mockEvent });
        }
        if (url === '/api/user/current') {
          return Promise.reject(new Error('Unauthorized'));
        }
        return Promise.reject(new Error('Unhandled API request'));
      });
    }
    
    let renderResult;
    
    await act(async () => {
      renderResult = render(
        <ThemeProvider theme={useDarkTheme ? darkTheme : theme}>
          <MemoryRouter initialEntries={[`/event/${mockEventId}`]}>
            <Routes>
              <Route path="/event/:eventId" element={<EventDetailPage />} />
              <Route path="/login" element={<div>Login Page</div>} />
              <Route path="/register" element={<div>Register Page</div>} />
            </Routes>
          </MemoryRouter>
        </ThemeProvider>
      );
      
      // Wait longer for component to initialize
      await new Promise(resolve => setTimeout(resolve, 100));
    });
    
    return renderResult;
  };

  it('renders loading state initially', async () => {
    const mockGetPromise = new Promise(resolve => {
      setTimeout(() => resolve({ data: mockEvent }), 1000);
    });
    
    apiClient.get.mockImplementation((url) => {
      if (url === `/api/event/${mockEventId}`) {
        return mockGetPromise;
      }
      if (url === '/api/user/current') {
        return Promise.resolve({ status: 200, data: { username: 'testuser' } });
      }
      if (url.includes('/api/comments')) {
        return Promise.resolve({ data: [] });
      }
      return Promise.reject(new Error('Unhandled API request'));
    });
    
    render(
      <ThemeProvider theme={theme}>
        <MemoryRouter initialEntries={[`/event/${mockEventId}`]}>
          <Routes>
            <Route path="/event/:eventId" element={<EventDetailPage />} />
          </Routes>
        </MemoryRouter>
      </ThemeProvider>
    );
    
    expect(screen.getByRole('progressbar')).toBeInTheDocument();
  });

  it('fetches and displays event details correctly', async () => {
    await setup();
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    expect(screen.getByText('Test Event')).toBeInTheDocument();
    expect(screen.getByText(/This is a test event description/)).toBeInTheDocument();
    expect(screen.getByText(/2023-04-15/)).toBeInTheDocument();
    expect(screen.getByText(/14:00/)).toBeInTheDocument();
    expect(screen.getByText(/Test Location/)).toBeInTheDocument();
    
    expect(apiClient.get).toHaveBeenCalledWith(`/api/event/${mockEventId}`);
  });

  it('shows login prompt when user is not authenticated', async () => {
    await setup(false, false);
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    // Using getByText with a function to handle whitespace and line breaks
    const loginText = screen.getByText((content, element) => {
      return element.tagName.toLowerCase() === 'p' && 
             element.textContent.includes('Please') && 
             element.textContent.includes('login') &&
             element.textContent.includes('to view the comments');
    });
    
    expect(loginText).toBeInTheDocument();
    expect(screen.getByText('login')).toBeInTheDocument();
    expect(screen.getByText('here')).toBeInTheDocument();
    expect(screen.queryByTestId('comment-section')).not.toBeInTheDocument();
  });

  it('displays comment section when user is authenticated', async () => {
    await setup();
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    expect(screen.queryByText((content, element) => {
      return element.tagName.toLowerCase() === 'p' && 
             element.textContent.includes('Please') && 
             element.textContent.includes('login');
    })).not.toBeInTheDocument();
    
    expect(screen.getByTestId('comment-section')).toBeInTheDocument();
    
    expect(CommentSection).toHaveBeenCalledWith({ eventId: 123 }, {});
  });

  it('handles invalid event ID', async () => {
    mockUseParams.mockReturnValue({ eventId: 'invalid' });
    
    // Mock API to return immediately to avoid loading state timeout
    apiClient.get.mockImplementation((url) => {
      if (url.includes('invalid')) {
        return Promise.resolve({ data: null });
      }
      if (url === '/api/user/current') {
        return Promise.resolve({ status: 200, data: { username: 'testuser' } });
      }
      return Promise.reject(new Error('Unhandled API request'));
    });
    
    render(
      <ThemeProvider theme={theme}>
        <MemoryRouter initialEntries={['/event/invalid']}>
          <Routes>
            <Route path="/event/:eventId" element={<EventDetailPage />} />
          </Routes>
        </MemoryRouter>
      </ThemeProvider>
    );
    
    // Wait for the component to finish rendering
    await waitFor(() => {
      expect(apiClient.get).toHaveBeenCalled();
    });
    
    // With invalid ID, it should not try to fetch a numeric event ID
    expect(apiClient.get).not.toHaveBeenCalledWith('/api/event/NaN');
  });

  it('handles API error when fetching event', async () => {
    apiClient.get.mockImplementation((url) => {
      if (url === `/api/event/${mockEventId}`) {
        return Promise.reject(new Error('Failed to load event'));
      }
      if (url === '/api/user/current') {
        return Promise.resolve({ status: 200, data: { username: 'testuser' } });
      }
      if (url.includes('/api/comments')) {
        return Promise.resolve({ data: [] });
      }
      return Promise.reject(new Error('Unhandled API request'));
    });
    
    const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    render(
      <ThemeProvider theme={theme}>
        <MemoryRouter initialEntries={[`/event/${mockEventId}`]}>
          <Routes>
            <Route path="/event/:eventId" element={<EventDetailPage />} />
          </Routes>
        </MemoryRouter>
      </ThemeProvider>
    );
    
    await waitFor(() => {
      expect(screen.getByText('Event not found.')).toBeInTheDocument();
    });
    
    expect(consoleErrorSpy).toHaveBeenCalled();
    
    consoleErrorSpy.mockRestore();
  });

  it('renders correctly in dark theme', async () => {
    await setup(true);

    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });

    expect(screen.getByText('Test Event')).toBeInTheDocument();
  });

  // Simplified WebSocket test that doesn't rely on mocking the internal implementation details
  it('establishes WebSocket connection with correct URL', async () => {
    const wsConstructorSpy = vi.fn();
    
    global.WebSocket = class MockSimpleWebSocket {
      constructor(url) {
        wsConstructorSpy(url);
        this.onopen = null;
        this.onclose = null;
        
        setTimeout(() => {
          if (this.onopen) this.onopen();
        }, 50);
      }
      
      close() {
        if (this.onclose) this.onclose();
      }
    };
    
    await setup();
    
    expect(wsConstructorSpy).toHaveBeenCalledWith(`ws://127.0.0.1:8000/ws/event/${mockEventId}/`);
  });

  // Simplified test that just checks the useState mock was invoked correctly
  it('sets up state for comments', async () => {
    await setup();
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    // Just verify the component fully renders with comments section
    expect(screen.getByTestId('comment-section')).toBeInTheDocument();
  });

  it('navigates to login page when login link is clicked', async () => {
    await setup(false, false);
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    const loginLink = screen.getByText('login');
    
    fireEvent.click(loginLink);
    
    expect(screen.getByText('Login Page')).toBeInTheDocument();
  });

  it('navigates to register page when register link is clicked', async () => {
    await setup(false, false);
    
    await waitFor(() => {
      expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, { timeout: 2000 });
    
    const registerLink = screen.getByText('here');
    
    fireEvent.click(registerLink);
    
    expect(screen.getByText('Register Page')).toBeInTheDocument();
  });
});